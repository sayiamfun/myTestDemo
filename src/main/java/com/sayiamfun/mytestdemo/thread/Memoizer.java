package com.sayiamfun.mytestdemo.thread;

/**
 * FutureTask
 *
 *
 *
 * 当一个计算的代价比较高，譬如比较耗时，或者耗资源，为了避免重复计算带来的浪费，当第一次计算后，通常会将结果缓存起来。
 *  比较常见的方式就是使用synchronized进行同步，但该方式带来的代价是被同步的代码只能被串行执行，如果有多个线程在排队对待计算结果，那么针对最后一个线程的计算时间可能比没有使用缓存的时间会更长。
 * 第二种方式是采用ConcurrentHashMap，但对于耗时比较长的计算过程来说，该方式也存在一个漏洞。
 *  如果在第一个线程正在计算的过程中，第二个线程开始获取结果，会发现缓存里没有缓存结果，因此第二个线程又启动了同样的计算，这样就导致重复计算，违背了缓存的初衷。计算过程越长，则出现这种重复计算的几率就会越大。
 *
 *
 * 通过第二种方式的缺点分析，得知真正要缓存的应该是计算是否已被启动，而不是等待漫长的计算过程结束后，再缓存结果。
 *  一旦从缓存中得知某个计算过程已被其他线程启动，则当前线程不需要再重新启动计算，只需要阻塞等待计算结果的返回。FutureTask就是实现该功能的最佳选择。
 */
public class Memoizer {

}
